\chapter{README}
\hypertarget{md_README}{}\label{md_README}\index{README@{README}}
\hypertarget{md_README_autotoc_md6}{}\doxysection{\texorpdfstring{(\+Unified Computer Image and Data-\/\+Processing)}{(Unified Computer Image and Data-Processing)}}\label{md_README_autotoc_md6}
\hypertarget{md_README_autotoc_md7}{}\doxysection{\texorpdfstring{AUTHOR}{AUTHOR}}\label{md_README_autotoc_md7}
{\bfseries{Name\+:}} Lucas Hern치ndez Abreu

{\bfseries{email\+:}} \href{mailto:lucas.hernandez.09@ull.edu.es}{\texttt{ lucas.\+hernandez.\+09@ull.\+edu.\+es}}\hypertarget{md_README_autotoc_md8}{}\doxysection{\texorpdfstring{LICENSE}{LICENSE}}\label{md_README_autotoc_md8}
LUCID (Unified Computer Image and Data-\/\+Processing) is a program to process any type of data concurrently. Copyright (C) 2023 Lucas Hern치ndez Abreu

This program is free software\+: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program. If not, see \href{https://www.gnu.org/licenses/}{\texttt{ https\+://www.\+gnu.\+org/licenses/}}.

Author\+: Lucas Hern치ndez Abreu

Contact\+: \href{mailto:lucas.hernandez.09@ull.edu.es}{\texttt{ lucas.\+hernandez.\+09@ull.\+edu.\+es}}\hypertarget{md_README_autotoc_md9}{}\doxysection{\texorpdfstring{INTRODUCTION}{INTRODUCTION}}\label{md_README_autotoc_md9}
LUCID (Unified Computer Image and Data-\/\+Processing) is a framework for processing data concurrently via the development of processing units. Each processing unit can have multiple instances that will run in parallel.

The following diagram illustrates its work\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{graph\ LR;}
\DoxyCodeLine{}
\DoxyCodeLine{subgraph\ Pipeline\ scope}
\DoxyCodeLine{\ \ \ \ PU1((PU1))\ -\/.-\/>\ PU2((PU2))\ -\/.-\/>\ PU3((PU3))}
\DoxyCodeLine{end;}
\DoxyCodeLine{}
\DoxyCodeLine{subgraph\ Main\ thread\ scope}
\DoxyCodeLine{\ \ \ \ MMM[MemoryManager]\ -\/-\/>|throught\ in\_queue|\ main}
\DoxyCodeLine{\ \ \ \ MMM\ -\/-\/>\ PU1}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ main-\/-\/>|throught\ out\_queue|\ MMM}
\DoxyCodeLine{\ \ \ \ PU3\ -\/.-\/>|Pushes\ into\ in\_queue|\ MMM}
\DoxyCodeLine{end;}

\end{DoxyCode}
\hypertarget{md_README_autotoc_md10}{}\doxysection{\texorpdfstring{Usage}{Usage}}\label{md_README_autotoc_md10}
First of all, we need some dependencies for LUCID to work\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Make}
\DoxyCodeLine{Cmake}
\DoxyCodeLine{gtest}

\end{DoxyCode}


Then you can clone this repository and

Once you have cloned this repository you have to make sure there is a {\ttfamily build} directory in it.

If there is no {\ttfamily build} directory execute the following command in the same level as the {\ttfamily src} directory\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mkdir\ build}

\end{DoxyCode}


Now to build the program go into the build directory with {\ttfamily cd build} and execute the following command\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{cmake\ ..}

\end{DoxyCode}


After you have built it you can find the executable at the {\ttfamily bin} directory.

Now run the executable in one of this three modes\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{LUCID\ (Unified\ Computer\ Image\ and\ Data-\/Processing)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Copyright\ (C)\ 2023\ \ Lucas\ Hern치ndez\ Abreu}
\DoxyCodeLine{\ \ \ \ \ \ \ \ This\ program\ comes\ with\ ABSOLUTELY\ NO\ WARRANTY}
\DoxyCodeLine{}
\DoxyCodeLine{Execute\ inside\ bin\ with:}
\DoxyCodeLine{\ \ \ \ ./lucid\ run\ <arg>}
\DoxyCodeLine{Valid\ args:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Debug\ -\/>\ [debug]|[-\/d]|[-\/-\/debug]:\ Shows\ the\ debug\ information:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ (operations\ in\ MemoryManager,\ semaphore\ statuses...)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Debug\ Processing\ Units\ -\/>\ [pudebug][-\/-\/pd][-\/-\/pu-\/debug]:\ shows\ the\ debug\ for\ the\ processing\ units}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ (operations\ inside\ the\ processing\ units)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Help\ -\/>\ [help]|[-\/h]|[-\/-\/help]:\ Shows\ this\ message}
\DoxyCodeLine{\ \ \ \ \ \ \ \ Profiling\ -\/>\ [profiling]:\ Shows\ the\ profiling\ information}

\end{DoxyCode}
\hypertarget{md_README_autotoc_md11}{}\doxysection{\texorpdfstring{Configuration}{Configuration}}\label{md_README_autotoc_md11}
For this framework you can add any number of processing units, make sure your units implementation look like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{processing__unit__interface_8h}{processing\_unit\_interface.h}}"{}}}
\DoxyCodeLine{\textcolor{keyword}{class\ }NewUnit\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classProcessingUnitInterface}{ProcessingUnitInterface}}\ \{}
\DoxyCodeLine{\ \ \ \ NewUnit();}
\DoxyCodeLine{\ \ \ \ \string~NewUnit();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ This\ function\ will\ always\ run:\ use\ it\ to\ instanciate\ unit\ variables.}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classProcessingUnitInterface_af37e1e66eb6fea8adcbc923441ae6738}{Start}}()\ \textcolor{keyword}{override};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ This\ function\ will\ always\ run:\ use\ it\ to\ get\ the\ data\ from\ the\ pipe\ and}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ proccess\ it}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{classProcessingUnitInterface_a7361ce594068a2366049238ada8ec1a2}{Run}}(\textcolor{keywordtype}{void}*)\ \textcolor{keyword}{override};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ This\ method\ is\ a\ placeholder\ for\ possible\ deletion\ in\ the\ unit}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classProcessingUnitInterface_a8bdb92bc733f84da5c6aca9db7e2c2e3}{Delete}}()\ \textcolor{keyword}{override};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Make\ sure\ to\ return\ a\ pointer\ to\ your\ new\ processing\ unit}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classProcessingUnitInterface}{ProcessingUnitInterface}}*\ \mbox{\hyperlink{classProcessingUnitInterface_a158005e77f828947eaae545a77bbaebd}{Clone}}()\ \textcolor{keyword}{override};}
\DoxyCodeLine{\};}

\end{DoxyCode}


You have examples into the {\ttfamily include/headers/pu/} and {\ttfamily include/definitions/pu/} directories.

For the program to work use the following list of steps in the main file\+:


\begin{DoxyEnumerate}
\item Instantiate the processing units to use.
\item Create a new \doxylink{classMemoryManager}{Memory\+Manager} object
\item Use the {\ttfamily Load\+Memory\+Manager(void\texorpdfstring{$\ast$}{*})} function to allocate the size for all the cells in the memory manager.
\item Create a pointer to a {\ttfamily \doxylink{classPipeline}{Pipeline}} and instantiate it with the first processing unit you want to use.
\item Add all the processing units you want to use for your process.
\item Run the pipe.
\item Iterate throught the data in the \doxylink{classMemoryManager}{Memory\+Manager} object\+: poping from In and pushing into out to start the process.
\item Wait for the pipe to finish with the {\ttfamily Wait\+Finish()} function. 
\end{DoxyEnumerate}